package xyz.binfish.misa.database;

import java.sql.SQLException;

import java.util.Set;

import xyz.binfish.misa.database.Database;
import xyz.binfish.misa.database.connections.MySQLConnection;
import xyz.binfish.misa.database.connections.SQLiteConnection;
import xyz.binfish.misa.database.schema.Schema;
import xyz.binfish.misa.database.query.QueryBuilder;
import xyz.binfish.misa.database.collection.Collection;

import xyz.binfish.misa.Misa;
import xyz.binfish.misa.Configuration;
import xyz.binfish.misa.exceptions.DatabaseException;
import xyz.binfish.logger.Logger;

public class DatabaseManager {

	private Database database = null;

	private final Schema schema;

	public static Logger logger = Logger.getLogger();

	public static boolean debugMode =
		(Configuration.getInstance().is("databaseDebugMode", false) ||
		Misa.makeDebug() ? true : false);

	public DatabaseManager() {
		this.schema = new Schema(this);
	}

	public Database getDatabase() throws SQLException {
		if(database == null) {
			switch(Configuration.getInstance().get("databaseType", null).toLowerCase()) {
				case "mysql":
					database = new MySQLConnection(this);
					break;
				case "sqlite":
					database = new SQLiteConnection(this);
					break;
				default:
					throw new RuntimeException("Invalid database type given, failed to create a new database connection.");
			}
		}

		if(database.isOpen()) {
			return database;
		}

		if(!database.open()) {
			throw new RuntimeException("Failed to connect to the database.");
		}

		return database;
	}

	public Schema getSchema() {
		return schema;
	}

	public QueryBuilder newQueryBuilder() {
		return new QueryBuilder(this);
	}

	public QueryBuilder newQueryBuilder(String table) {
		return new QueryBuilder(this, table);
	}

	/*
	 * Executes the given SQL statement, which returns single Collection object.
	 *
	 * @param query an SQL statement to be sent to the database, typically
	 * 		a static SQL SELECT statement.
	 * @return Collection object that contains the data produced
	 * by the given query; never null.
	 * @throws SQLException if a database access error occurs.
	 */
	public Collection query(String query) throws SQLException {
		if(debugMode)
			logger.debug("query(String query) was called with the following SQL query.\nSQL: " + query);

		return getDatabase().runQuery(query);
	}

	/*
	 * Executes the SQL statement generated by the query builder, which returns a single
	 * Collection object.
	 *
	 * @param query QueryBuilder instance that should be sent to the database, typically
	 * a static SQL SELECT statement.
	 * @return Collection object that contains the data produced
	 * by the given query; never null.
	 * @throws SQLException        if a database access error occurs.
	 * @throws SQLTimeoutException when the driver has determined that the timeout
	 *                             value that was specified by the setQueryTimeout
	 *                             method has been exeeded and has at least attempted to cancel
	 *                             the currently running Statement.
	 */
	public Collection query(QueryBuilder query) throws SQLException {
		return query(query.toSQL());
	}

	/*
	 * Generates a prepared statement object and executes the SQL statement, which 
	 * must be an SQL Data Manipulation Language statement, such as INSERT, UPDATE 
	 * or DELETE; or an SQL statement that returns nothing, such as a DDL statement.
	 *
	 * @param query an SQL statement to be sent to the database, typically a static SQL DML statement.
	 * @return the row count for SQL Data Manipulation Language statements
	 * or 0 for SQL statements that return nothing.
	 * @throws SQLException        if a database access error occurs
	 * @throws SQLTimeoutException when the driver has determined that the
	 *                             timeout value that was specified by the setQueryTimeout
	 *                             method has been exceeded and has at least attempted to cancel
	 *                             the currently running Statement.
	 */
	public int queryUpdate(String query) throws SQLException {
		if(debugMode)
			logger.debug("queryUpdate(String query) was called with the following SQL query.\nSQL: " + query);

		return getDatabase().runQueryUpdate(query);
	}

	/*
	 * Generates a prepared statement object and executes the SQL statement, which
	 * must be an SQL Data Manipulation Language statement, such as INSERT, UPDATE or DELETE;
	 * or an SQL statement that returns nothing, such as a DDL statement.
	 *
	 * @param query QueryBuilder instance that should be sent to the database, typically a
	 * static SQL DML statement.
	 * @return the row count for SQL Data Manipulation Language statements
	 * or 0 for SQL statements that return nothing.
	 * @throws SQLException        if a database access error occurs.
	 * @throws SQLTimeoutException when the driver has determined that the
	 *                             timeout value that was specified by the setQueryTimeout
	 *                             method has been exceeded and has at least attempted to cancel
	 *                             the currently running Statement.
	 */
	public int queryUpdate(QueryBuilder query) throws SQLException {
		return queryUpdate(query.toSQL());
	}

	/*
	 * Generates a prepared statement object and executes the SQL statement, which
	 * must be an SQL INSERT statement, such as INSERT; After the query has been
	 * executed the prepared statement will be used to generate a set of
	 * keys, referring to the IDs of the inserted rows.
	 *
	 * @param query an SQL statement to be sent to the database, typically a static SQL INSERT statement.
	 * @return a set of IDs referring to the insert rows.
	 * @throws SQLException        if a database access error occurs.
	 * @throws SQLTimeoutException when the driver has determined that the
	 *                             timeout value that was specified by the setQueryTimeout
	 *                             method has been exceeded and has at least attempted to cancel
	 *                             the currently running Statement.
	 */
	public Set<Integer> queryInsert(String query) throws SQLException {
		if(debugMode)
			logger.debug("queryInsert(String query) was called with the following SQL query.\nSQL: " + query);

		if(!query.toUpperCase().startsWith("INSERT INTO")) {
			throw new DatabaseException("queryInsert was called with a query without an INSERT statement.");
		}

		return getDatabase().runQueryInsert(query);
	}

	/*
	 * Generates a prepared statement object and executes the SQL statement, which
	 * must be an SQL INSERT statement, such as INSERT; After the query has been
	 * executed the prepared statement will be used to generate a set of
	 * keys, referring to the IDs of the inserted rows.
	 *
	 * @param queryBuilder QueryBuilder instance that should be sent to the
	 * database, typically a static SQL INSERT statement.
	 * @return a set of IDs referring to the insert rows.
	 * @throws SQLException        if a database access error occurs.
	 * @throws SQLTimeoutException when the driver has determined that the
	 *                             timeout value that was specified by the setQueryTimeout
	 *                             method has been exceeded and has at least attempted to cancel
	 *                             the currently running Statement.
	 */
	public Set<Integer> queryInsert(QueryBuilder queryBuilder) throws SQLException {
		String query = queryBuilder.toSQL();

		if(debugMode)
			logger.debug("queryInsert(QueryBuilder queryBuilder) was called with the following SQL query.\nSQL: " + query);

		if(query == null) {
			throw new SQLException("null query was generated, null can not be used as a valid query");
		}

		if(!query.toUpperCase().startsWith("INSERT INTO")) {
			throw new DatabaseException("queryInsert was called with a query without an INSERT statement.");
		}

		return getDatabase().runQueryInsert(queryBuilder);

	}
}
